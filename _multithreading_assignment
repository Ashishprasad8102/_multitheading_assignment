{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c5db7ed2-23f9-496d-812e-cd4ac73ff3ee",
   "metadata": {},
   "outputs": [],
   "source": [
    "1>Threading in Python refers to the ability to execute multiple threads within the same process.\n",
    "A thread is the smallest unit of execution within a process, and threading allows a program to \n",
    "perform multiple tasks concurrently, making efficient use of the CPU and reducing waiting time.\n",
    "\n",
    "In Python, threads are used to achieve concurrent execution, allowing multiple tasks to run\n",
    "concurrently within a single process. Threads are a way to implement multitasking or multi-threading\n",
    "in Python. They are lightweight execution units that share the same memory space, which makes \n",
    "them efficient for certain types of tasks.\n",
    "\n",
    "In Python, the module used to handle threads is called threading. The threading module provides classes \n",
    "and functions for working with threads and implementing multi-threading in Python.\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5e3ecfc5-7d67-4f5a-be5f-c29705c91ece",
   "metadata": {},
   "outputs": [],
   "source": [
    "2>\n",
    "  1>activeCount:The activeCount() method in the threading module is used to get the number of active\n",
    "    thread objects in the current Python process. An active thread is a thread that has been created \n",
    "    and has not yet finished executing or been explicitly terminated.\n",
    "    \n",
    "  2>currentThread():In Python's threading module, the currentThread() function is used to retrieve a \n",
    "    reference to the currently executing thread object. This function returns an instance of the Thread\n",
    "    class, which represents the thread in which currentThread() is called.\n",
    "\n",
    "  3>enumerate() :In Python's threading module, the enumerate() function is used to obtain a list of all \n",
    "    currently active Thread objects. It returns a list of Thread instances that are currently running or\n",
    "    alive.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "27c237ff-840c-4903-82e1-7d898e254271",
   "metadata": {},
   "outputs": [],
   "source": [
    "3> \n",
    "1>run():In Python, the run() function is not a built-in function or a standard part of the language.\n",
    "However, it is commonly used in the context of multi-threading and custom thread classes that extend\n",
    "the threading.Thread class.\n",
    "\n",
    "2>start():In Python, the start() function is a method available in the threading.Thread class, which\n",
    "is used to start the execution of a new thread. When you create a Thread object and define the target \n",
    "function that should run in the new thread, you need to call the start() method to initiate the \n",
    "execution of that function in a separate thread.\n",
    "\n",
    "3>join():In Python, the join() method is used with threads to wait for a thread to complete its\n",
    "execution before the program continues with the rest of its code. It is part of the Thread class\n",
    "provided by the threading module.\n",
    "\n",
    "4>IsAlive():In Python's threading module, the is_alive() method is used to determine whether a Thread \n",
    "object is currently running (alive) or has completed its execution (dead). The method returns a boolean\n",
    "value: True if the thread is running, and False if it has finished executing.\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "23e4d623-be18-47de-a60a-55c1b38427a2",
   "metadata": {},
   "outputs": [],
   "source": [
    "4>import threading\n",
    "\n",
    "def print_squares(numbers):\n",
    "    for num in numbers:\n",
    "        print(f\"Squared: {num} -> {num**2}\")\n",
    "\n",
    "def print_cubes(numbers):\n",
    "    for num in numbers:\n",
    "        print(f\"Cubed: {num} -> {num**3}\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    numbers_list = [1, 2, 3, 4, 5]\n",
    "\n",
    "    # Create two threads, one for printing squares and the other for cubes\n",
    "    thread_squares = threading.Thread(target=print_squares, args=(numbers_list,))\n",
    "    thread_cubes = threading.Thread(target=print_cubes, args=(numbers_list,))\n",
    "\n",
    "    # Start the threads\n",
    "    thread_squares.start()\n",
    "    thread_cubes.start()\n",
    "\n",
    "    # Wait for both threads to finish\n",
    "    thread_squares.join()\n",
    "    thread_cubes.join()\n",
    "\n",
    "    print(\"Main thread exiting.\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2ade1dc6-5fc6-41aa-84b6-2c89be08cf9f",
   "metadata": {},
   "outputs": [],
   "source": [
    "5>Advantages of Multithreading:\n",
    "\n",
    "Concurrency and Responsiveness: Multithreading allows you to achieve concurrent execution, enabling your\n",
    "program to perform multiple tasks simultaneously. This concurrency improves the responsiveness of the\n",
    "application, especially for I/O-bound operations, by preventing blocking.\n",
    "\n",
    "Resource Sharing: Threads share the same memory space within a process, making it easier to share\n",
    "data between threads. This shared memory can be leveraged for communication and data exchange,\n",
    "reducing the need for complex inter-process communication mechanisms.\n",
    "\n",
    "Efficient Resource Utilization: Threads are lightweight compared to processes, which means they have \n",
    "lower memory overhead and can be created and destroyed faster. This efficiency makes multithreading \n",
    "a good choice for handling numerous short-lived tasks.\n",
    "\n",
    "Simplified Design for Certain Tasks: For some tasks, multithreading can simplify the program design \n",
    "compared to using multiple processes. This is particularly true when handling shared data or resources.\n",
    "\n",
    "Disadvantages of Multithreading:\n",
    "\n",
    "Complexity and Synchronization: Multithreading introduces the complexity of concurrent execution,\n",
    "which can lead to race conditions and other synchronization issues. Proper synchronization mechanisms,\n",
    "such as locks and semaphores, must be used to avoid data corruption and ensure thread safety.\n",
    "\n",
    "Global Interpreter Lock (GIL): In some programming languages like Python, there's a Global Interpreter \n",
    "Lock (GIL) that restricts true parallelism for CPU-bound tasks. This limitation can reduce the \n",
    "performance gain when using multithreading for CPU-bound operations.\n",
    "\n",
    "Debugging and Deadlocks: Debugging multithreaded programs can be challenging due to the non-deterministic\n",
    "nature of threads. Additionally, improper synchronization can lead to deadlocks, where threads get stuck\n",
    "indefinitely.\n",
    "\n",
    "Resource Contention: With multiple threads sharing resources, contention can arise, causing bottlenecks\n",
    "and reduced performance. For instance, excessive thread contention on a shared resource might slow down\n",
    "the overall application.\n",
    "\n",
    "Difficulty in Debugging and Testing: Reproducing and debugging race conditions or synchronization issues\n",
    "can be challenging due to their non-deterministic nature. Testing multithreaded applications thoroughly\n",
    "to cover all possible interleavings can be time-consuming.\n",
    "\n",
    "In summary, multithreading is a powerful technique for concurrent execution and improving responsiveness,\n",
    "especially for I/O-bound tasks. However, it also introduces complexities related to synchronization,\n",
    "debugging, and resource management. Careful consideration should be given to thread safety and the specific requirements of the task at hand when deciding whether to use multithreading in a particular application. For CPU-bound tasks, other approaches like multiprocessing or asynchronous programming may be more suitable to achieve true parallelism and performance gains.\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d7f2c4d4-a142-450b-804e-562cbc868a48",
   "metadata": {},
   "outputs": [],
   "source": [
    "6>Deadlock:\n",
    "\n",
    "Deadlock is a situation in which two or more threads are unable to proceed because each is waiting for\n",
    "the other to release a resource that they need. This results in a standstill, and none of the threads\n",
    "can make progress. Deadlocks can happen due to improper handling of synchronization mechanisms like \n",
    "locks or semaphores.\n",
    "\n",
    "Race Condition is a situation where the behavior of a program depends on the relative timing or \n",
    "interleaving of threads. It occurs when multiple threads access shared resources or data without\n",
    "proper synchronization, and the result of the program becomes unpredictable."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
